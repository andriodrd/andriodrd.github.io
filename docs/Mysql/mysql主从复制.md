# Mysql主从复制

## 1	为什么要做主从复制

> 1. 在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运行。
> 2. 做数据的热备，主库宕机后能够及时替换主库，保证业务可用性。
> 3. 架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。

## 2	Mysql主从复制的流程

![image-20210128110440886](assets/image-20210128110440886.png)

> 1. 主库db的更新事件（update，insert，delete）被写到binlog
> 2. 主库创建一个binlog dump thread，把binlog的内容发送到从库
> 3. 从库启动并发起连接，连接到主库
> 4. 从库启动以后，创建一个i/o线程，读取主库传过来binlog里面的内容并写入到relay log
> 5. 从库启动之后，创建一个sql线程，从relay log里面读取内容，从exec_master_log_pos位置开始执行读取到的更新事件，将更新内容写入到slave的db

## 3	Mysql主从复制的原理

> 1. Mysql主从复制是一个异步的复制过程，主库发送更新事件到从库，从库读取更新记录，并执行更新记录，使得从库的内容与主库保持一致
>
> 2. binlog
>
>    - `binary log`主库中保存所有更新事件日志的二进制文件。`binlog`是数据库服务启动的一刻起，保存数据库所有变更记录（数据库结构和内容）的文件。在主库中，只要有更新事件出现，就会被依次第写入到`binlog`中，之后会推送到从库中作为从库进行复制的数据源。
>
>    - binlog输出线程：每当有从库连接到主库的时候，主库都会创建一个线程然后发送binlog内容到从库。 对于每一个即将发送给从库的sql事件，binlog输出线程会将其锁住。一旦该事件被线程读取完之后，该锁会被释放，即使在该事件完全发送到从库的时候，该锁也会被释放。
>
>    - 从库I/O线程：当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，该线程连接到主库并请求主库发送binlog里面的更新记录到从库上。 从库I/O线程读取主库的binlog输出线程发送的更新并拷贝这些更新到本地文件，其中包括relay log文件
>
>    - 从库的SQL线程：从库创建一个SQL线程，这个线程读取从库i/o线程写到relay log的更新事件并执行
>
>    - 总结：综上所述，可知：对于每一个主从复制的连接，使得在进行复制时，从库的读和写进行了分离。因此，即使负责执行的线程运行较慢，负责读取更新语句的线程并不会因此变得缓慢，比如说，如果从库有一段时间没运行了，当它再次启动的时候，尽管它的SQL线程执行比较慢，它的i/o线程可以快速地从主库里读取所有的Binlog内容。这样一来，即使从库在sql线程执行完所有读取到的语句前停止运行了，I/O线程也至少完全读取了所有的内容，并将其安全地备份在从库本地的relay log，随时准备在从库下一次启动的时候执行语句。
>
>    - 从库生成两个线程，一个I/O线程，一个SQL线程；
>
>      i/o线程去请求主库 的binlog，并将得到的binlog日志写到relay log(中继日志) 文件中；
>
>      主库会生成一个 log dump 线程，用来给从库 i/o线程传binlog；
>
>      SQL 线程，会读取relay log文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致；

## 4.	Docker部署主从复制

> 1. 解决方法：半同步复制---解决数据丢失的问题
> 2. 并行复制----解决从库复制延迟的问题